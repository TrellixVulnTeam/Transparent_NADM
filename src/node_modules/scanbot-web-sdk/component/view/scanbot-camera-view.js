"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScanbotCameraView = void 0;
const preact_1 = require("preact");
const compat_1 = __importDefault(require("preact/compat"));
class ScanbotCameraView extends compat_1.default.Component {
    constructor(props) {
        super(props);
        this.state = {};
    }
    createImageData(maxSmallerSize = 0) {
        if (!this.ctx) {
            this.getCanvas();
        }
        if (!this.ctx) {
            return;
        }
        if (!this.video) {
            return;
        }
        const { videoWidth, videoHeight } = this.video;
        const { frameWidth, frameHeight } = this.calculateFrameSize(maxSmallerSize);
        this.ctx.drawImage(this.video, 0, 0, videoWidth, videoHeight, 0, 0, frameWidth, frameHeight);
        const imageData = this.ctx.getImageData(0, 0, frameWidth, frameHeight);
        return imageData;
    }
    calculateFrameSize(maxSmallerSize) {
        const { videoWidth, videoHeight } = this.video;
        let frameWidth = videoWidth, frameHeight = videoHeight;
        if (maxSmallerSize > 0 && videoWidth != 0 && videoHeight != 0) {
            const aspectRatio = videoWidth / videoHeight;
            if (videoWidth < videoHeight) {
                frameWidth = videoWidth < maxSmallerSize ? videoWidth : maxSmallerSize;
                frameHeight = frameWidth / aspectRatio;
            }
            else {
                frameHeight = videoHeight < maxSmallerSize ? videoHeight : maxSmallerSize;
                frameWidth = frameHeight * aspectRatio;
            }
        }
        return { frameWidth, frameHeight };
    }
    convertToViewportPoints(points, maxSmallerSize) {
        if (!points || !this.video) {
            return;
        }
        const { clientWidth, clientHeight } = this.video;
        const { frameWidth, frameHeight } = this.calculateFrameSize(maxSmallerSize);
        if (clientWidth == 0 || clientHeight == 0 || frameWidth == 0 || frameHeight == 0) {
            return;
        }
        const containerAspectRatio = clientWidth / clientHeight;
        const videoAspectRatio = frameWidth / frameHeight;
        let x = 0;
        let y = 0;
        let containerScale;
        if (videoAspectRatio > containerAspectRatio) {
            containerScale = clientHeight / frameHeight;
            x = (frameWidth - clientWidth / containerScale) / 2;
        }
        else {
            containerScale = clientWidth / frameWidth;
            y = (frameHeight - clientHeight / containerScale) / 2;
        }
        // Detection result was done on an image of different size than
        // the video stream presented in the contained element,
        // when drawing points on the container, re-calculate based on container size
        const newPoints = points.map(pt => ({
            x: containerScale * (pt.x - x),
            y: containerScale * (pt.y - y)
        }));
        return newPoints;
    }
    getCanvas() {
        if (!this.video) {
            return null;
        }
        if (this.video.videoWidth === 0) {
            // Video should be rendered, but isn't rendered yet
            return null;
        }
        if (!this.ctx) {
            this.canvas = document.createElement("canvas");
            this.canvas.className = "scanbot-sdk-canvas-element";
            this.canvas.width = this.video.videoWidth;
            this.canvas.height = this.video.videoHeight;
            this.ctx = this.canvas.getContext("2d");
        }
        return this.canvas;
    }
    _requestUserMedia() {
        return __awaiter(this, void 0, void 0, function* () {
            const constraints = {
                video: this.props.videoConstraints
            };
            this.stream = yield navigator.mediaDevices.getUserMedia(constraints);
            try {
                if (this.video) {
                    this.video.srcObject = this.stream;
                }
                return { hasUserMedia: true };
            }
            catch (_a) {
                this.videoObjectUrl = window.URL.createObjectURL(this.stream);
                return {
                    hasUserMedia: true,
                    src: this.videoObjectUrl,
                };
            }
        });
    }
    componentDidMount() {
        return __awaiter(this, void 0, void 0, function* () {
            const { onError, onReady } = this.props;
            try {
                yield this._requestUserMedia();
                if (onReady) {
                    onReady();
                }
            }
            catch (err) {
                if (onError) {
                    onError(err);
                }
            }
        });
    }
    componentWillUnmount() {
        this.canvas = null;
        this.ctx = null;
        if (this.stream) {
            if (this.stream.getVideoTracks && this.stream.getAudioTracks) {
                this.stream.getVideoTracks().map(track => track.stop());
                this.stream.getAudioTracks().map(track => track.stop());
            }
            this.stream = null;
        }
        if (this.videoObjectUrl) {
            window.URL.revokeObjectURL(this.videoObjectUrl);
            this.videoObjectUrl = null;
        }
    }
    render() {
        return preact_1.h("video", { 
            // @ts-ignore
            autoplay: true, src: this.videoObjectUrl, muted: true, playsinline: true, class: "scanbot-camera-view", ref: ref => {
                this.video = ref;
            }, style: {
                display: "block",
                width: "100%",
                height: "100%",
                objectFit: "cover",
            } });
    }
}
exports.ScanbotCameraView = ScanbotCameraView;
