"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentOutline = void 0;
const compat_1 = __importDefault(require("preact/compat"));
const preact_1 = require("preact");
const classnames_1 = __importDefault(require("classnames"));
require("../styles/main.css");
class DocumentOutline extends compat_1.default.Component {
    constructor() {
        super();
        this.outlineClassName = "scanbot-document-outline";
        this.hintLabelClassName = "scanbot-document-hint-text";
        this.PULL_FORCE = 4;
        this.MIN_SPEED = 100;
        this.state = {
            text: "Initializing..."
        };
    }
    render() {
        const { ok, text, validPoints } = this.state;
        const visible = this.props.visible && validPoints;
        const polygonClasses = classnames_1.default({
            [this.outlineClassName]: true,
            [`${this.outlineClassName}-visible`]: visible,
            [`${this.outlineClassName}-hidden`]: !visible,
            [`${this.outlineClassName}-ok`]: ok
        });
        const labelClasses = classnames_1.default({
            [this.hintLabelClassName]: true,
            [`${this.hintLabelClassName}-visible`]: visible,
            [`${this.hintLabelClassName}-hidden`]: !visible,
        });
        return preact_1.h("div", { style: { width: "100%", height: "100%", position: "absolute", left: 0, top: 0 } },
            preact_1.h("svg", { style: { width: "100%", height: "100%" } },
                preact_1.h("polygon", { style: this.props.style.polygon, class: polygonClasses, ref: ref => {
                        this.polygon = ref;
                    } })),
            this.props.showLabel && preact_1.h("label", { style: this.props.style.label, class: labelClasses, dangerouslySetInnerHTML: { __html: text } }));
    }
    update(ok, points, text) {
        if (points) {
            if (!this.overlayPolygonCurrent) {
                this.overlayPolygonCurrent = points;
            }
            if (!this.overlayPolygonTarget) {
                requestAnimationFrame(this.animate.bind(this));
            }
            this.overlayPolygonTarget = points;
        }
        this.setState({
            ok,
            text,
            validPoints: !!points,
        });
    }
    animate(currentTime) {
        if (!this.overlayPolygonTarget) {
            return;
        }
        const timeStep = (!this.animationLastTime ? 0 : currentTime - this.animationLastTime) / 1000;
        let totalOffset = 0;
        for (let i = 0; i < 4; ++i) {
            const f = this.overlayPolygonCurrent[i];
            const t = this.overlayPolygonTarget[i];
            const offsetX = this.absMin(this.absMax(this.MIN_SPEED * Math.sign(t.x - f.x) * timeStep, (t.x - f.x) * this.PULL_FORCE * timeStep), t.x - f.x);
            const offsetY = this.absMin(this.absMax(this.MIN_SPEED * Math.sign(t.y - f.y) * timeStep, (t.y - f.y) * this.PULL_FORCE * timeStep), t.y - f.y);
            f.x += offsetX;
            f.y += offsetY;
            totalOffset += Math.abs(offsetX);
            totalOffset += Math.abs(offsetY);
        }
        const svgPointsStr = this.overlayPolygonCurrent.map(pt => `${pt.x},${pt.y}`).join(' ');
        if (this.polygon) {
            // Race condition after detection has been stopped
            this.polygon.setAttribute('points', svgPointsStr);
        }
        if (totalOffset < 1 && this.animationLastTime !== null) {
            this.overlayPolygonTarget = null;
            this.animationLastTime = null;
        }
        else {
            this.animationLastTime = currentTime;
            requestAnimationFrame(this.animate.bind(this));
        }
    }
    absMin(a, b) {
        return Math.abs(a) < Math.abs(b) ? a : b;
    }
    absMax(a, b) {
        return Math.abs(a) > Math.abs(b) ? a : b;
    }
}
exports.DocumentOutline = DocumentOutline;
