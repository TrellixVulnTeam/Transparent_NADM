"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("preact"));
const preact_1 = require("preact");
const document_outline_1 = require("./view/document-outline");
const document_scanner_configuration_1 = require("./model/document-scanner-configuration");
const scanbot_camera_view_1 = require("./view/scanbot-camera-view");
const ShutterButton_1 = require("./view/ShutterButton");
class DocumentScannerView extends React.Component {
    constructor(props) {
        super(props);
        this.onVideoReady = () => {
            const { onReady } = this.props;
            if (onReady) {
                onReady(this);
            }
        };
        this.onVideoError = (err) => {
            const { onError } = this.props;
            if (onError) {
                onError(err);
            }
        };
        this.defaultCaptureButtonClick = () => __awaiter(this, void 0, void 0, function* () {
            const result = yield this.detectAndCrop();
            this.configuration.onDocumentDetected(result);
        });
        this.state = {
            action: this.defaultAction,
        };
        if (!DocumentScannerView.isSupported()) {
            const message = "Camera can only be accessed if the content is served via HTTPS, or on localhost. Check DocumentScannerView.isSupported() before creating the scanner.";
            throw Error(message);
        }
    }
    get defaultAction() {
        return this.autoCaptureEnabled ? 'searching' : 'manual';
    }
    get enabled() {
        return (this.state.action == 'searching' || this.state.action == 'capturing') && !this.disposed;
    }
    get autoCaptureEnabled() {
        return this.configuration.autoCaptureEnabled;
    }
    get configuration() {
        return document_scanner_configuration_1.DocumentScannerConfiguration.fromJson(this.props.configuration);
    }
    get bridge() {
        return this.props.bridge;
    }
    static isSupported() {
        if (location.hostname !== 'localhost' && location.protocol !== 'https:') {
            return false;
        }
        return true;
    }
    /**
     * Public API functions
     */
    static create(configuration, bridge) {
        return __awaiter(this, void 0, void 0, function* () {
            const container = document.getElementById(configuration.containerId);
            if (!container) {
                throw Error("Unable to initialize ScanbotSDK: Cannot find container element with the id provided.");
            }
            return new Promise((resolve, reject) => {
                preact_1.render(preact_1.h(DocumentScannerView, { container: container, configuration: configuration, bridge: bridge, onReady: resolve, onError: reject }), container);
            });
        });
    }
    dispose() {
        const { container } = this.props;
        if (!container) {
            throw Error("Component wasn't created with createDocumentScanner. Remove component from render tree to dispose.");
        }
        this.componentWillUnmount();
        preact_1.render(null, container);
    }
    detectAndCrop() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.setState({ action: 'processing' });
                // console.log("action: processing");
                const imageData = this.camera.createImageData();
                const result = yield this.bridge.post('detectAndCropDocument', [imageData]);
                return result;
            }
            finally {
                this.setState({ action: this.defaultAction });
                // console.log("action: ", this.defaultAction);
            }
        });
    }
    /**
     * Internal functions
     */
    componentDidMount() {
        this.disposed = false;
        this.detect();
    }
    componentWillUnmount() {
        this.disposed = true;
        this.handleAutoCapture(false);
    }
    detect() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.enabled) {
                    return;
                }
                const detectionResult = yield this.detectInWebWorker();
                if (!this.enabled) {
                    return;
                }
                if (!detectionResult) {
                    return;
                }
                if (!this.outline) {
                    // This check is here because upon stopping the camera, state is still detecting,
                    // however, after awaiting WebWorker result, outline is already undefined,
                    return;
                }
                const statusString = this.getStatusString(detectionResult);
                const isOk = (statusString === 'OK');
                const points = this.camera.convertToViewportPoints(detectionResult.polygon, DocumentScannerView.DEFAULT_DETECTION_RESOLUTION);
                this.outline.update(isOk, points, this.configuration.text.hint[statusString]);
                yield this.handleAutoCapture(isOk);
            }
            finally {
                requestAnimationFrame(this.detect.bind(this));
            }
        });
    }
    getStatusString(detectionResult) {
        if (this.configuration.ignoreBadAspectRatio && detectionResult.detectionStatus === "OK_BadAspectRatio") {
            return "OK";
        }
        return detectionResult.detectionStatus;
    }
    detectInWebWorker() {
        return __awaiter(this, void 0, void 0, function* () {
            const imageData = this.camera.createImageData(DocumentScannerView.DEFAULT_DETECTION_RESOLUTION);
            if (!imageData) {
                return;
            }
            const args = [imageData, this.configuration.acceptedAngleScore, this.configuration.acceptedSizeScore];
            return yield this.bridge.post('detectDocument', args);
        });
    }
    handleAutoCapture(statusOk) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.configuration.autoCaptureEnabled) {
                return;
            }
            if (statusOk && !this.autoCaptureToken) {
                // console.log('ScanbotSDK: Starting auto-capture delay...');
                this.updateButton("capturing");
                const delay = (1 - this.configuration.autoCaptureSensitivity) * 3000;
                this.autoCaptureToken = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                    // console.log('ScanbotSDK: Auto-capture triggered!');
                    this.autoCaptureToken = undefined;
                    if (!this.enabled) {
                        return;
                    }
                    const result = yield this.detectAndCrop();
                    if (result.success && this.configuration.onDocumentDetected) {
                        this.configuration.onDocumentDetected(result);
                    }
                }), delay);
            }
            else if (!statusOk && this.autoCaptureToken) {
                //console.log('ScanbotSDK: STOP auto-capture');
                this.updateButton("searching");
                clearTimeout(this.autoCaptureToken);
                this.autoCaptureToken = undefined;
            }
        });
    }
    updateButton(action) {
        this.setState({ action: action });
    }
    render() {
        var _a, _b, _c, _d, _e;
        const { action } = this.state;
        const { configuration } = this;
        const buttonStyle = (_a = configuration.style) === null || _a === void 0 ? void 0 : _a.captureButton;
        return (preact_1.h("div", { style: { position: "relative", width: "100%", height: "100%" } },
            preact_1.h(scanbot_camera_view_1.ScanbotCameraView, { videoConstraints: configuration.videoConstraints, onReady: this.onVideoReady, onError: this.onVideoError, ref: (ref) => {
                    this.camera = ref;
                } }),
            preact_1.h(document_outline_1.DocumentOutline, { style: {
                    polygon: (_c = (_b = configuration.style) === null || _b === void 0 ? void 0 : _b.outline) === null || _c === void 0 ? void 0 : _c.polygon,
                    label: (_e = (_d = configuration.style) === null || _d === void 0 ? void 0 : _d.outline) === null || _e === void 0 ? void 0 : _e.label
                }, showLabel: action == 'searching' || action == 'capturing', visible: action != 'processing', ref: (ref) => {
                    this.outline = ref;
                } }),
            preact_1.h(ShutterButton_1.ShutterButton, { color: (buttonStyle === null || buttonStyle === void 0 ? void 0 : buttonStyle.color) ? buttonStyle.color : "FFF", action: action, onClick: configuration.onCaptureButtonClick || this.defaultCaptureButtonClick })));
    }
}
exports.default = DocumentScannerView;
DocumentScannerView.DEFAULT_DETECTION_RESOLUTION = 600; // taken from EdgeBasedDetectorParameters::documentDefault
